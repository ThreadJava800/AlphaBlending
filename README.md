# Alpha blending
> Программа рассчитывает цвет для каждого пикселя по формуле `(alphaFront * colorFront) + (1 - alphaFront) * colorBack`.

## Содержание
1. [Общая инфомация](#general)
2. [Ход работы](#progress)
3. [Сравнение оптимизаций](#compare)
4. [Углубимся в ассемблер](#assemble)
5. [Заключение](#conclusion)

## GОбщая инфомация <a name="general"></a>

Я решил использовать этот алгоритм, чтобы глубже разобраться в интринсиках и `пареллелизме уровня инструкций`. В частности, в `shuffle`-ах. 

Ниже приведён результат работы алгоритма:\
![Alpha Blending](https://github.com/ThreadJava800/AlphaBlending/blob/main/readmepics/result.png)

|  |  |
| --- | --- |
| `Компилятор` | g++ (GCC) 12.2.1 |
| `Флаги оптимизации` | -mavx2
| `ОС` | Arch Linux x86_64 (6.2.7-arch1-1)|
| `Процессор` | AMD Ryzen 5 5500U

## Ход работы <a name="progress"></a>

Я реализовал две версии программы. Первая - [наивная](https://github.com/ThreadJava800/AlphaBlending/blob/main/naive.cpp)\
И вторая - с [использованием интринсиков](https://github.com/ThreadJava800/AlphaBlending/blob/main/optim1.cpp) (в основном с помощью `shuffle`-ов).

## Сравнение реализаций <a name="compare"></a>

*Время работы измерялось лишь для расчётов (графика и считывание картинок из памяти не считались).*

Ниже приведена таблица сравнений для разных оптимизаций:

`-O2`:

| Реализация | Теоретическое ускорение | Фактическое ускорение |
| --- | --- | --- |
| `Наивная` | 1x (3505 us) | 1x (3505 ± 34.8 us) |
| `AVX256` | 8x (438.1 us) | 7x (497 ± 60.5 us) |

-O3:

| Реализация | Теоретическое ускорение | Фактическое ускорение |
| --- | --- | --- |
| `Наивная` | 1x (3552.5 us) | 1x (3552.5 ± 34 us) |
| `AVX256` | 8x (444 us) | 7x (506.7 ± 79.6 us) |

-Ofast:

| Реализация | Теоретическое ускорение | Фактическое ускорение |
| --- | --- | --- |
| `Наивная` | 1x (3555 us) | 1x (3555 ± 39.1 us) |
| `AVX256` | 8x (444.4 us) | 6.9x (511.6 ± 84 us) |

## Углубимся в ассемблер <a name="assemble"></a>
Я решил исследовать, как работают различные `g++` оптимизации.

`-O1` работает с локальными переменными через регистры, в отличии от `-O0`, который использует стек.
Это рабоает быстрее, т.к. нет надобности в пересылке данных из регистра в стек и наоборот.\
Также, `-O1` анализирует код и не считает одно и тоже значение дважды .\
Кроме того, `-O1` заменяет несколько команд одной (например, mov + sar = movzx)

Код на си:\
![C code](https://github.com/ThreadJava800/AlphaBlending/blob/main/readmepics/c_code.png)\
Ассемблерный код (`-O0`):\
![O0](https://github.com/ThreadJava800/AlphaBlending/blob/main/readmepics/o0.png)\
Ассемблерный код (`-O1`):\
![O1](https://github.com/ThreadJava800/AlphaBlending/blob/main/readmepics/o1.png)

`-O2` совершает все расчёты на блоке вычисление адресов (что гораздо быстрее).

![O2](https://github.com/ThreadJava800/AlphaBlending/blob/main/readmepics/o2.png)

`-O3` и `-Ofast` имеют одинаковый эффект.
Они меняют команды местами, чтобы использовать возможности вычислительного конвеера для ускорения вычислений.\
Также, они используют более сложные ассемблерный команды, которые сочетают в себе несколько логических операций.\
Примечательно, что ни одна из оптимизаций не смогла "додуматься" до использование `shuffle`-ов.\
Также, важно отметить, что `-O3` и `-Ofast` разворачивают циклы гораздо сильнее, чем другие оптимизации.\
Примечательно, что эти оптимизации работают за то же время, что и `-O2`.
(Возможно, из-за огромного количества ассемблерных команд).

![C code](https://github.com/ThreadJava800/AlphaBlending/blob/main/readmepics/c_code3.png)

![O3](https://github.com/ThreadJava800/AlphaBlending/blob/main/readmepics/o3.png)

## Заключение <a name="conclusion"></a>
Как мы можем видеть, даже `-Ofast` не способен использовать интринсики на полную (компилятор, например, не решается использовать `shuffle`-ы для оптимизации). И, если честно, я рад этому. Это означает, что наша работа пока ещё не бессмысленна.